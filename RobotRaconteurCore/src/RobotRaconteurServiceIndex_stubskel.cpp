// Copyright 2011-2019 Wason Technology, LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//This file is automatically generated. DO NOT EDIT!

#include "RobotRaconteur/RobotRaconteurServiceIndex_stubskel.h"
#include <boost/algorithm/string.hpp>
#include <boost/lexical_cast.hpp>
namespace RobotRaconteurServiceIndex
{

std::string RobotRaconteurServiceIndexFactory::GetServiceName()
{
return "RobotRaconteurServiceIndex";
}
std::string RobotRaconteurServiceIndexFactory::DefString()
{
std::string out(
"service RobotRaconteurServiceIndex\n"
"struct NodeInfo\n"
"field string NodeName\n"
"field uint8[16] NodeID\n"
"field string{int32} ServiceIndexConnectionURL\n"
"end struct\n"
"struct ServiceInfo\n"
"field string Name\n"
"field string RootObjectType\n"
"field string{int32} RootObjectImplements\n"
"field string{int32} ConnectionURL\n"
"field varvalue{string} Attributes\n"
"end struct\n"
"object ServiceIndex\n"
"function ServiceInfo{int32} GetLocalNodeServices()\n"
"function NodeInfo{int32} GetRoutedNodes()\n"
"function NodeInfo{int32} GetDetectedNodes()\n"
"event LocalNodeServicesChanged()\n"
"end object\n"
);
return out;
}
RR_SHARED_PTR<RobotRaconteur::StructureStub> RobotRaconteurServiceIndexFactory::FindStructureStub(boost::string_ref s)
{
std::vector<std::string> res;
boost::split(res,s,boost::is_from_range('.','.'));
std::string servicetype=res.at(0);
std::string objecttype=res.at(1);
if (objecttype=="NodeInfo") return RobotRaconteur::rr_cast<RobotRaconteur::StructureStub>(RR_MAKE_SHARED<NodeInfo_stub>(GetNode()));
if (objecttype=="ServiceInfo") return RobotRaconteur::rr_cast<RobotRaconteur::StructureStub>(RR_MAKE_SHARED<ServiceInfo_stub>(GetNode()));
throw RobotRaconteur::ServiceException("Invalid structure stub type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> RobotRaconteurServiceIndexFactory::PackStructure(RR_INTRUSIVE_PTR<RobotRaconteur::RRStructure> structin)
{
std::string type=structin->RRType();std::vector<std::string> res;
boost::split(res,type,boost::is_from_range('.','.'));
std::string servicetype=res.at(0);
std::string objecttype=res.at(1);
if (servicetype != "RobotRaconteurServiceIndex") return GetNode()->PackStructure(structin);
RR_SHARED_PTR<RobotRaconteur::StructureStub> stub=FindStructureStub(type);
return stub->PackStructure(structin);
throw RobotRaconteur::ServiceException("Invalid structure stub type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRValue> RobotRaconteurServiceIndexFactory::UnpackStructure(RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> mstructin)
{
boost::string_ref type=mstructin->GetTypeString().str();std::vector<std::string> res;
boost::split(res,type,boost::is_from_range('.','.'));
std::string servicetype=res.at(0);
std::string objecttype=res.at(1);
if (servicetype != "RobotRaconteurServiceIndex") return GetNode()->UnpackStructure(mstructin);
RR_SHARED_PTR<RobotRaconteur::StructureStub> stub=FindStructureStub(type);
return stub->UnpackStructure(mstructin);
throw RobotRaconteur::ServiceException("Invalid structure stub type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> RobotRaconteurServiceIndexFactory::PackPodArray(RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseArray> structure)
{
throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseArray> RobotRaconteurServiceIndexFactory::UnpackPodArray(RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> structure)
{
throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> RobotRaconteurServiceIndexFactory::PackPodMultiDimArray(RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseMultiDimArray> structure)
{
throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRPodBaseMultiDimArray> RobotRaconteurServiceIndexFactory::UnpackPodMultiDimArray(RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> structure)
{
throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> RobotRaconteurServiceIndexFactory::PackNamedArray(RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseArray> structure)
{
	throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseArray> RobotRaconteurServiceIndexFactory::UnpackNamedArray(RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> structure)
{
	throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> RobotRaconteurServiceIndexFactory::PackNamedMultiDimArray(RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseMultiDimArray> structure)
{
	throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRNamedBaseMultiDimArray> RobotRaconteurServiceIndexFactory::UnpackNamedMultiDimArray(RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> structure)
{
	throw RobotRaconteur::ServiceException("Invalid pod type.");
}
RR_SHARED_PTR<RobotRaconteur::ServiceStub> RobotRaconteurServiceIndexFactory::CreateStub(boost::string_ref type, boost::string_ref path, RR_SHARED_PTR<RobotRaconteur::ClientContext> context)
{
std::vector<std::string> res;
boost::split(res,type,boost::is_from_range('.','.'));
std::string servicetype=res.at(0);
std::string objecttype=res.at(1);
if (servicetype != "RobotRaconteurServiceIndex") return GetNode()->GetServiceType(servicetype)->CreateStub(type,path,context);
if (objecttype=="ServiceIndex") { RR_SHARED_PTR<ServiceIndex_stub> o=(RR_MAKE_SHARED<ServiceIndex_stub>(path,context)); o->RRInitStub(); return o; }
throw RobotRaconteur::ServiceException("Invalid structure stub type.");
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> NodeInfo_stub::PackStructure(RR_INTRUSIVE_PTR<RobotRaconteur::RRValue> s)
{
RR_INTRUSIVE_PTR<NodeInfo > s2=RobotRaconteur::rr_cast<NodeInfo >(s);
std::vector<RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> > vret;
vret.push_back(RobotRaconteur::CreateMessageElement("NodeName",RobotRaconteur::rr_cast<RobotRaconteur::MessageElementData>(RobotRaconteur::stringToRRArray(s2->NodeName))));
vret.push_back(RobotRaconteur::CreateMessageElement("NodeID",RobotRaconteur::rr_cast<RobotRaconteur::MessageElementData>(s2->NodeID)));
vret.push_back(RobotRaconteur::CreateMessageElement("ServiceIndexConnectionURL",RobotRaconteur::rr_cast<RobotRaconteur::MessageElementData>(RRGetNode()->PackMapType<int32_t,RobotRaconteur::RRArray<char>  >(s2->ServiceIndexConnectionURL))));
return RobotRaconteur::CreateMessageElementNestedElementList(RobotRaconteur::DataTypes_structure_t,"RobotRaconteurServiceIndex.NodeInfo",RR_MOVE(vret));
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRStructure> NodeInfo_stub::UnpackStructure(RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> m)
{
RR_INTRUSIVE_PTR<NodeInfo > ret( new NodeInfo());
ret->NodeName=RobotRaconteur::RRArrayToString(RobotRaconteur::MessageElement::FindElement(m->Elements,"NodeName")->CastData<RobotRaconteur::RRArray<char> >());
ret->NodeID=RobotRaconteur::MessageElement::FindElement(m->Elements,"NodeID")->CastData<RobotRaconteur::RRArray<uint8_t > >();
ret->ServiceIndexConnectionURL=RobotRaconteur::rr_cast<RobotRaconteur::RRMap<int32_t,RobotRaconteur::RRArray<char>  > >((RRGetNode()->UnpackMapType<int32_t,RobotRaconteur::RRArray<char>  >(RobotRaconteur::MessageElement::FindElement(m->Elements,"ServiceIndexConnectionURL")->CastDataToNestedList(RobotRaconteur::DataTypes_vector_t))));
return ret;
}

RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> ServiceInfo_stub::PackStructure(RR_INTRUSIVE_PTR<RobotRaconteur::RRValue> s)
{
RR_INTRUSIVE_PTR<ServiceInfo > s2=RobotRaconteur::rr_cast<ServiceInfo >(s);
std::vector<RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> > vret;
vret.push_back(RobotRaconteur::CreateMessageElement("Name",RobotRaconteur::rr_cast<RobotRaconteur::MessageElementData>(RobotRaconteur::stringToRRArray(s2->Name))));
vret.push_back(RobotRaconteur::CreateMessageElement("RootObjectType",RobotRaconteur::rr_cast<RobotRaconteur::MessageElementData>(RobotRaconteur::stringToRRArray(s2->RootObjectType))));
vret.push_back(RobotRaconteur::CreateMessageElement("RootObjectImplements",RobotRaconteur::rr_cast<RobotRaconteur::MessageElementData>(RRGetNode()->PackMapType<int32_t,RobotRaconteur::RRArray<char>  >(s2->RootObjectImplements))));
vret.push_back(RobotRaconteur::CreateMessageElement("ConnectionURL",RobotRaconteur::rr_cast<RobotRaconteur::MessageElementData>(RRGetNode()->PackMapType<int32_t,RobotRaconteur::RRArray<char>  >(s2->ConnectionURL))));
vret.push_back(RobotRaconteur::CreateMessageElement("Attributes",RobotRaconteur::rr_cast<RobotRaconteur::MessageElementData>(RRGetNode()->PackMapType<std::string,RobotRaconteur::RRValue >(s2->Attributes))));
return RobotRaconteur::CreateMessageElementNestedElementList(RobotRaconteur::DataTypes_structure_t,"RobotRaconteurServiceIndex.ServiceInfo",RR_MOVE(vret));
}
RR_INTRUSIVE_PTR<RobotRaconteur::RRStructure> ServiceInfo_stub::UnpackStructure(RR_INTRUSIVE_PTR<RobotRaconteur::MessageElementNestedElementList> m)
{
RR_INTRUSIVE_PTR<ServiceInfo > ret( new ServiceInfo());
ret->Name=RobotRaconteur::RRArrayToString(RobotRaconteur::MessageElement::FindElement(m->Elements,"Name")->CastData<RobotRaconteur::RRArray<char> >());
ret->RootObjectType=RobotRaconteur::RRArrayToString(RobotRaconteur::MessageElement::FindElement(m->Elements,"RootObjectType")->CastData<RobotRaconteur::RRArray<char> >());
ret->RootObjectImplements=RobotRaconteur::rr_cast<RobotRaconteur::RRMap<int32_t,RobotRaconteur::RRArray<char>  > >((RRGetNode()->UnpackMapType<int32_t,RobotRaconteur::RRArray<char>  >(RobotRaconteur::MessageElement::FindElement(m->Elements,"RootObjectImplements")->CastDataToNestedList(RobotRaconteur::DataTypes_vector_t))));
ret->ConnectionURL=RobotRaconteur::rr_cast<RobotRaconteur::RRMap<int32_t,RobotRaconteur::RRArray<char>  > >((RRGetNode()->UnpackMapType<int32_t,RobotRaconteur::RRArray<char>  >(RobotRaconteur::MessageElement::FindElement(m->Elements,"ConnectionURL")->CastDataToNestedList(RobotRaconteur::DataTypes_vector_t))));
ret->Attributes=RobotRaconteur::rr_cast<RobotRaconteur::RRMap<std::string,RobotRaconteur::RRValue > >((RRGetNode()->UnpackMapType<std::string,RobotRaconteur::RRValue >(RobotRaconteur::MessageElement::FindElement(m->Elements,"Attributes")->CastDataToNestedList(RobotRaconteur::DataTypes_dictionary_t))));
return ret;
}

ServiceIndex_stub::ServiceIndex_stub(boost::string_ref path, RR_SHARED_PTR<RobotRaconteur::ClientContext> c) : RobotRaconteur::ServiceStub(path,c){ }
void ServiceIndex_stub::RRInitStub()
{
}

RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,ServiceInfo  > > ServiceIndex_stub::GetLocalNodeServices()
{
throw RobotRaconteur::NotImplementedException("Not available in async only code");
}

RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > > ServiceIndex_stub::GetRoutedNodes()
{
throw RobotRaconteur::NotImplementedException("Not available in async only code");
}

RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > > ServiceIndex_stub::GetDetectedNodes()
{
	throw RobotRaconteur::NotImplementedException("Not available in async only code");
}

boost::signals2::signal<void ()>& ServiceIndex_stub::get_LocalNodeServicesChanged()
{
return rrvar_LocalNodeServicesChanged;
}

void ServiceIndex_stub::DispatchEvent(RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_m)
{
if (rr_m->MemberName=="LocalNodeServicesChanged")
{
get_LocalNodeServicesChanged()();
return;
}
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
void ServiceIndex_stub::DispatchPipeMessage(RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
void ServiceIndex_stub::DispatchWireMessage(RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m)
{
throw RobotRaconteur::MemberNotFoundException("Member not found");
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry>ServiceIndex_stub::CallbackCall(RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_m)
{
RobotRaconteur::MessageStringRef ename=rr_m->MemberName;
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_mr=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_CallbackCallRet, ename);
rr_mr->ServicePath=rr_m->ServicePath;
rr_mr->RequestID=rr_m->RequestID;
throw RobotRaconteur::MemberNotFoundException("Member not found");
}

std::string ServiceIndex_stub::RRType()
{
return "RobotRaconteurServiceIndex.ServiceIndex";
}
void ServiceIndex_stub::RRClose()
{
rrvar_LocalNodeServicesChanged.disconnect_all_slots();
ServiceStub::RRClose();
}

void ServiceIndex_stub::async_GetLocalNodeServices(boost::function<void (RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,ServiceInfo  > >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallReq,"GetLocalNodeServices");
AsyncProcessRequest(rr_req,boost::bind(&ServiceIndex_stub::rrend_GetLocalNodeServices, RobotRaconteur::rr_cast<ServiceIndex_stub>(shared_from_this()),_1,_2,rr_handler ),rr_timeout);
}

void ServiceIndex_stub::rrend_GetLocalNodeServices(RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,ServiceInfo  > > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler)
{
if (err)
{
handler(RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,ServiceInfo  > >(),err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,ServiceInfo  > >(),RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=m->FindElement("return");
handler(RobotRaconteur::rr_cast<RobotRaconteur::RRMap<int32_t,ServiceInfo  > >((RRGetNode()->UnpackMapType<int32_t,ServiceInfo  >(me->CastDataToNestedList(RobotRaconteur::DataTypes_vector_t)))), RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}
void ServiceIndex_stub::async_GetRoutedNodes(boost::function<void (RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallReq,"GetRoutedNodes");
AsyncProcessRequest(rr_req,boost::bind(&ServiceIndex_stub::rrend_GetRoutedNodes, RobotRaconteur::rr_cast<ServiceIndex_stub>(shared_from_this()),_1,_2,rr_handler ),rr_timeout);
}

void ServiceIndex_stub::rrend_GetRoutedNodes(RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler)
{
if (err)
{
handler(RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > >(),err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > >(),RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=m->FindElement("return");
handler(RobotRaconteur::rr_cast<RobotRaconteur::RRMap<int32_t,NodeInfo  > >((RRGetNode()->UnpackMapType<int32_t,NodeInfo  >(me->CastDataToNestedList(RobotRaconteur::DataTypes_vector_t)))), RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}
void ServiceIndex_stub::async_GetDetectedNodes(boost::function<void (RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout)
{
RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> rr_req=RobotRaconteur::CreateMessageEntry(RobotRaconteur::MessageEntryType_FunctionCallReq,"GetDetectedNodes");
AsyncProcessRequest(rr_req,boost::bind(&ServiceIndex_stub::rrend_GetDetectedNodes, RobotRaconteur::rr_cast<ServiceIndex_stub>(shared_from_this()),_1,_2,rr_handler ),rr_timeout);
}

void ServiceIndex_stub::rrend_GetDetectedNodes(RR_INTRUSIVE_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler)
{
if (err)
{
handler(RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > >(),err);
return;
}
if (m->Error != RobotRaconteur::MessageErrorType_None)
{
handler(RR_INTRUSIVE_PTR<RobotRaconteur::RRMap<int32_t,NodeInfo  > >(),RobotRaconteur::RobotRaconteurExceptionUtil::MessageEntryToException(m));
return;
}
RR_INTRUSIVE_PTR<RobotRaconteur::MessageElement> me=m->FindElement("return");
handler(RobotRaconteur::rr_cast<RobotRaconteur::RRMap<int32_t,NodeInfo  > >((RRGetNode()->UnpackMapType<int32_t,NodeInfo  >(me->CastDataToNestedList(RobotRaconteur::DataTypes_vector_t)))), RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>());
}

}
